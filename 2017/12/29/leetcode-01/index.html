<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>leetcode-01 | PLM&#39;s Notes | 好好学习，天天笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="leetcode,树">
    <meta name="description" content="leetcode题目">
<meta name="keywords" content="leetcode,树">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-01">
<meta property="og:url" content="http://plmsmile.github.io/2017/12/29/leetcode-01/index.html">
<meta property="og:site_name" content="PLM&#39;s Notes">
<meta property="og:description" content="leetcode题目">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/tree/bstree_03.jpg">
<meta property="og:updated_time" content="2018-12-13T08:00:25.721Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode-01">
<meta name="twitter:description" content="leetcode题目">
<meta name="twitter:image" content="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/tree/bstree_03.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="PLM&#39;s Notes" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">PLM</h5>
          <a href="mailto:plmsmile@126.com" title="plmsmile@126.com" class="mail">plmsmile@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                类别
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about">
                <i class="icon icon-lg icon-user"></i>
                关于我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/plmsmile" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">leetcode-01</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">leetcode-01</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-12-29T06:08:03.000Z" itemprop="datePublished" class="page-time">
  2017-12-29
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/leetcode/">leetcode</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#有序列表转二叉查找树-109"><span class="post-toc-number">1.</span> <span class="post-toc-text">有序列表转二叉查找树-109</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二叉树的最小深度-111"><span class="post-toc-number">2.</span> <span class="post-toc-text">二叉树的最小深度-111</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二叉树遍历"><span class="post-toc-number">3.</span> <span class="post-toc-text">二叉树遍历</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#先序遍历-144"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">先序遍历-144</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#中序遍历-094"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">中序遍历-094</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#后序遍历-145"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">后序遍历-145</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#层次遍历-102"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">层次遍历-102</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#发现重复的数字-287"><span class="post-toc-number">4.</span> <span class="post-toc-text">发现重复的数字-287</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#合并两条有序链表-021"><span class="post-toc-number">5.</span> <span class="post-toc-text">合并两条有序链表-021</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#合并多条有序链表-023"><span class="post-toc-number">6.</span> <span class="post-toc-text">合并多条有序链表-023</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#z型打印二叉树-103"><span class="post-toc-number">7.</span> <span class="post-toc-text">Z型打印二叉树-103</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二叉树路径求和-112.113.437"><span class="post-toc-number">8.</span> <span class="post-toc-text">二叉树路径求和-112.113.437</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#有序链表转平衡bst-109"><span class="post-toc-number">9.</span> <span class="post-toc-text">有序链表转平衡BST-109</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#序列化二叉树-297"><span class="post-toc-number">10.</span> <span class="post-toc-text">序列化二叉树-297</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数字全排列-046"><span class="post-toc-number">11.</span> <span class="post-toc-text">数字全排列-046</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#重复数字全排列-047"><span class="post-toc-number">12.</span> <span class="post-toc-text">重复数字全排列-047</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#n皇后问题-051"><span class="post-toc-number">13.</span> <span class="post-toc-text">N皇后问题-051</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#查找第k大的数总结"><span class="post-toc-number">14.</span> <span class="post-toc-text">查找第k大的数总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#查找最小的k个数的总结"><span class="post-toc-number">15.</span> <span class="post-toc-text">查找最小的k个数的总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数组中次数超过一半的数-169"><span class="post-toc-number">16.</span> <span class="post-toc-text">数组中次数超过一半的数-169</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#主元素2-229"><span class="post-toc-number">17.</span> <span class="post-toc-text">主元素2-229</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#最长不重复子字符串-003"><span class="post-toc-number">18.</span> <span class="post-toc-text">最长不重复子字符串-003</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#丑数-263-264-313"><span class="post-toc-number">19.</span> <span class="post-toc-text">丑数-263-264-313</span></a></li></ol>
        </nav>
    </aside>


<article id="post-leetcode-01" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">leetcode-01</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-12-29 14:08:03" datetime="2017-12-29T06:08:03.000Z" itemprop="datePublished">2017-12-29</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/leetcode/">leetcode</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>leetcode题目</p>
</blockquote>
<a id="more"></a>
<h1 id="有序列表转二叉查找树-109">有序列表转二叉查找树-109</h1>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">Convert Sorted List to Binary Search Tree</a></p>
<h1 id="二叉树的最小深度-111">二叉树的最小深度-111</h1>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a></p>
<p>最小深度：根节点到某个叶子节点的最短路径。</p>
<ul>
<li>为空，返回0</li>
<li>左孩子为空，则结果在右孩子</li>
<li>右孩子为空，则结果在左孩子</li>
<li>左右均不为空，返回小的+1</li>
</ul>
<h1 id="二叉树遍历">二叉树遍历</h1>
<h2 id="先序遍历-144">先序遍历-144</h2>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Preorder Traversal</a></p>
<p>根、左、右。<strong>栈</strong>。</p>
<ul>
<li>先把根节点入栈</li>
<li>栈不为空时，出栈一个元素</li>
<li>访问该元素，<strong>右孩子进栈，左孩子进栈</strong>。 因为出栈，先出左孩子，再出右孩子。</li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/144_btree_pre_order/btree_preorder.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_order(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vpre;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* p = st.top();</span><br><span class="line">        vpre.push_back(p-&gt;val);</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="comment">// 右进、左进；出时：左先出</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            st.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            st.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vpre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历-094">中序遍历-094</h2>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Inorder Traversal</a></p>
<p><strong>思路</strong></p>
<p>左、根、右。使用<strong>栈</strong>。</p>
<ol style="list-style-type: decimal">
<li>p=root</li>
<li>p不为空，p入栈，一直向左走<code>p = p.left</code>，扫描它的左孩子，所有左孩子依次入栈</li>
<li>p为空时，<code>p = st.top()</code> ，<strong>p位于栈顶</strong>，显然<strong>没有左孩子或者左孩子已经遍历过</strong>，<strong>p访问出栈</strong>。</li>
<li><strong>扫描右孩子</strong> <code>p = p.right</code></li>
</ol>
<p>从根节点开始，一直向左，<strong>所有的左孩子入栈</strong>， 出栈一个节点，<strong>访问</strong>，<strong>它的右孩子入栈</strong>。</p>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/94_btree_in_order/btree_inorder.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_traversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (p || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="comment">// 根节点入栈</span></span><br><span class="line">            st.push(p);</span><br><span class="line">            <span class="comment">// 扫描左孩子</span></span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// p位于栈顶，左孩子已经被遍历过或者没有左孩子，直接出栈访问</span></span><br><span class="line">            p = st.top();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="comment">// 扫描右孩子</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历-145">后序遍历-145</h2>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></p>
<p>思路</p>
<p>左孩子、右孩子、根节点。使用栈。使用<code>pre</code>记录<strong>上一次遍历的节点</strong>。</p>
<ul>
<li>根节点入栈</li>
<li>栈不为空，访问栈顶元素p</li>
<li><strong>直接访问</strong>p的条件：<strong>p没有左右孩子</strong> or <strong>左右孩子刚刚遍历结束</strong>，只要pre是左或者右孩子即可</li>
<li>p可以直接访问，则<strong>访问出栈</strong></li>
<li>p不能直接访问，则<strong>左右孩子入栈</strong></li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/145_btree_post_order/btree_postorder.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post_order(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="comment">// 前一次访问的节点</span></span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* p = st.top();</span><br><span class="line">        <span class="comment">// 0. 检查是否可以直接访问p</span></span><br><span class="line">        <span class="keyword">bool</span> no_child = (p-&gt;left == <span class="literal">nullptr</span> &amp;&amp; p-&gt;right == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">bool</span> pre_is_child = (pre == p-&gt;left || pre == p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == pre) &#123;</span><br><span class="line">            pre_is_child = <span class="literal">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 1. p无左右子树 or 左右子树刚刚遍历完，直接访问p</span></span><br><span class="line">        <span class="keyword">if</span> (no_child || pre_is_child) &#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            pre = p;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 2. 需要将p的左右孩子入栈</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                st.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                st.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历-102">层次遍历-102</h2>
<p>层次遍历，使用队列。</p>
<p>从上到下 <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a> 和从下到上 <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a>。</p>
<p>如果只需要顺序放在一个数组里面，则不需要分层，直接层次遍历即可。</p>
<p>但是此题，需要分层构建vector。</p>
<p><strong>数量记录思路</strong></p>
<p>不是很好。</p>
<ul>
<li>队列层次遍历</li>
<li>当前层在队列中的数量：<code>cur_remain</code></li>
<li>下一层的数量：<code>next_level</code></li>
<li><code>cur_remain == 0</code>时， 就切换到下一层</li>
</ul>
<p>[关键代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 当前层，在队列里面的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> cur_remain = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一层的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> next_level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 存入队列</span></span><br><span class="line">        res[res.size() - <span class="number">1</span>].push_back(now-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右孩子入队</span></span><br><span class="line">        <span class="keyword">if</span> (now-&gt;left) &#123;</span><br><span class="line">            q.push(now-&gt;left);</span><br><span class="line">            next_level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;right) &#123;</span><br><span class="line">            q.push(now-&gt;right);</span><br><span class="line">            next_level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层数量--</span></span><br><span class="line">        cur_remain--;</span><br><span class="line">        <span class="comment">// 切换到下一层</span></span><br><span class="line">        <span class="keyword">if</span> (cur_remain == <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            cur_remain = next_level;</span><br><span class="line">            next_level = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一次遍历一层的思路</strong></p>
<p>很好，<strong>掌握</strong>！</p>
<ul>
<li>一次while循环，保证<strong>当前队列里面只有当前层的元素</strong>，用vector记录当前层的序列</li>
<li><code>q.size()</code> 获得当前层元素数量，然后<strong>本次循环，只从队列里面出这么多元素</strong>。</li>
<li>依次<strong>遍历当前层的所有元素</strong>，<strong>出队，同时左右孩子入队</strong></li>
<li>q为空，则所有层遍历结束</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保证当前队列的循环只有当前层的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; level_order(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="comment">// 一次while循环，出掉当前层的所有元素，下一层的元素全部入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="comment">// 当前层的数量和遍历结果序列</span></span><br><span class="line">        <span class="keyword">int</span> level_num = q.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curv;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_num; i++) &#123;</span><br><span class="line">            TreeNode* p = q.front();</span><br><span class="line">            <span class="comment">// p的左右孩子入队列</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) q.push(p-&gt;right);</span><br><span class="line">            <span class="comment">// p出队，放到当前层的vector中</span></span><br><span class="line">            q.pop();</span><br><span class="line">            curv.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放到末尾，就是从下到上</span></span><br><span class="line">        <span class="comment">// res.insert(res.begin(), curv); </span></span><br><span class="line">        res.push_back(curv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="发现重复的数字-287">发现重复的数字-287</h1>
<p><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">Find the Duplicate Number</a>， 类似于<a href="https://plmsmile.github.io/2017/07/29/aim2offer/#题目2">aim2offer中查找重复的数字</a></p>
<blockquote>
<p>数组a，有n+1个数，都在[1,n]范围内，只有一个重复的元素。找到它</p>
</blockquote>
<p><strong>二分思路</strong></p>
<p><code>[1, n]</code>这个范围有n个数。划分为两个范围<code>[1, m]</code>和<code>[m+1, n]</code></p>
<ul>
<li><strong>每次去遍历整个数组</strong>，统计<strong>两个范围</strong>内的<strong>数字的数目</strong></li>
<li>统计整个数组中元素在<code>[1, m]</code>范围内的个数<span class="math inline">\(c_1\)</span></li>
<li>统计整个数组中元素在<code>[m+1, n]</code>范围内的个数<span class="math inline">\(c_2\)</span></li>
</ul>
<p>[1, m]这m个数字的数量是<code>c</code></p>
<ul>
<li>如果 <code>c &gt; m</code>， 则<code>1, m]</code>内一定存在重复的数，<code>e = m</code></li>
<li>否则，<code>[m+1, n]</code>一定存在重复的数，<code>s = m + 1</code></li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/287_find_the_duplicate_num/find_duplicate_num.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到一个重复的数字</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      a -- 数组，n+1个元素，范围[1,n]，至少有一个重复的数字</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      dup -- 重复的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_duplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n;</span><br><span class="line">    <span class="keyword">int</span> dup = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 不断缩小范围</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 统计[l,m]在a中的出现次数</span></span><br><span class="line">        <span class="keyword">int</span> count = count_range(a, l, m);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                dup = l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [l, m]有重复的</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; (m - l + <span class="number">1</span>)) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// [m+1, r]有重复的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到数组a中，[min, max]这些数的出现次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_range</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= min &amp;&amp; a[i] &lt;= max) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="合并两条有序链表-021">合并两条有序链表-021</h1>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener"></a></p>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Merge Two Sorted Lists</a> ，和<a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#归并排序">归并排序的Merge操作</a> 很类似。</p>
<p>考虑鲁棒性</p>
<p><strong>思路</strong></p>
<ul>
<li><span class="math inline">\(l_1\)</span>与<span class="math inline">\(l_2\)</span>若有一个为空的，则<strong>返回另一个</strong></li>
<li><strong>初始化新的head</strong>，选择<span class="math inline">\(l_1\)</span>与<span class="math inline">\(l_2\)</span>中第一个节点较小的那个</li>
<li>while循环，谁小选谁</li>
<li>结束之后，直接<strong>把未空的链表链接上</strong>即可</li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/21_merge_two_lists/merge_two_lists.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化head</span></span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        head = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历两条链表，每次选择小的追加到p的后面</span></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 某一条链表还有剩余</span></span><br><span class="line">    <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="合并多条有序链表-023">合并多条有序链表-023</h1>
<p><a href="https://leetcode.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">Merge k Sorted Lists</a></p>
<p>我们已经会合并2条链表了，可以使用<a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#归并排序">归并排序</a>和<a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#折半插入">二分查找</a>的思想来合并多个列表。</p>
<p><strong>示例</strong></p>
<p>现在有<code>1, 2, 3, 4, 5, 6</code>条链表</p>
<ul>
<li>第一步：<code>1-6</code>，<code>2-5</code>，<code>3-4</code>合并，得到新的<code>1, 2, 3</code></li>
<li>第二步：<code>1-3</code>合并，2不动，得到新的<code>1, 2</code></li>
<li>第三步：<code>1-2</code>合并， 得到新的<code>2</code>， 合并完成</li>
<li>返回<code>list[0]</code></li>
</ul>
<p><strong>总结</strong></p>
<ol style="list-style-type: decimal">
<li>直到<code>len==1</code> <strong>合并到只有一条链表</strong>，合并到list[0]</li>
<li>对于当前len，<strong>折半两两合并</strong>，<code>i</code>和<code>len-i-1</code>合并，放到前面<code>lists[i]</code></li>
<li><strong>len缩减一半</strong>，<code>len=(len+1)/2</code></li>
</ol>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/22_merge_k_sorted_list/merge_k_lists.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lists.empty()) &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = lists.size();</span><br><span class="line">  	<span class="comment">// 直到只有一条链表</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      	<span class="comment">// 依次合并前后两条链表</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">          	<span class="comment">// 合并放到list[i]</span></span><br><span class="line">        	lists[i] = mergeTwoLists(lists[i], lists[len - i - <span class="number">1</span>]);</span><br><span class="line">      	&#125;</span><br><span class="line">      	len = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="z型打印二叉树-103">Z型打印二叉树-103</h1>
<p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Zigzag Level Order Traversal</a></p>
<p>参考<a href="https://plmsmile.github.io/2017/12/29/leetcode-01/#层次遍历-102">层次遍历</a> <strong>一次遍历一层</strong>的思路。</p>
<ul>
<li>一次遍历一层，得到当前层的遍历结果</li>
<li>单数，从左向右；偶数，从右向左</li>
<li>每次遍历一个元素，把左右孩子入队</li>
</ul>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/tree/bstree_03.jpg" style="display:block; margin:auto" width="60%"></p>
<ul>
<li>根节点，向右走</li>
<li>第二层，向左走</li>
<li>向右走，从队头出，孩子先左后右，加到队尾</li>
<li>向左走，从队尾出，孩子先右后左，加到队首</li>
</ul>
<p><strong>两个栈的思路</strong></p>
<p>栈1初始存放根节点，栈2为空</p>
<ul>
<li><strong>向右</strong>走，<strong>栈1全部出栈</strong>，<strong>先左后右</strong>孩子依次压入栈2，栈底-栈顶，栈2为<code>2 3</code></li>
<li><strong>向左</strong>走，<strong>栈2全部出栈</strong>，<strong>先右后左</strong>孩子依次压入栈1，栈1为<code>7 6 5 4</code></li>
<li>向右走，栈1出栈，左右孩子依次压入栈2，栈2为<code>8 9 10 11 12 13 14 15</code></li>
<li>向左走，栈2出栈，结束</li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/103_zigzag_level_order/btree_zlevel_order.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用两个栈z型层次打印二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st2;</span><br><span class="line"></span><br><span class="line">    st1.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st1.empty() || !st2.empty()) &#123;</span><br><span class="line">        <span class="comment">// 向右走</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curv;</span><br><span class="line">        <span class="keyword">if</span> (!st1.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st1.empty()) &#123;</span><br><span class="line">                TreeNode* p = st1.top();</span><br><span class="line">                st1.pop();</span><br><span class="line">                curv.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) st2.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) st2.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 向左走</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st2.empty()) &#123;</span><br><span class="line">                TreeNode* p = st2.top();</span><br><span class="line">                st2.pop();</span><br><span class="line">                curv.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) st1.push(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) st1.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(curv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树路径求和-112.113.437">二叉树路径求和-112.113.437</h1>
<p><strong>题目1 从根节点到叶子求和-112</strong></p>
<p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Path Sum</a>， <code>EASY</code></p>
<blockquote>
<p>给一颗二叉树和一个sum值，判断是否有从根节点到叶子节点的路径，使得路径上的节点求和等于sum</p>
</blockquote>
<p><strong>思路</strong></p>
<p><strong>做减法</strong></p>
<ul>
<li>根节点为空，False</li>
<li>没有孩子，判断<code>root.val == sum</code></li>
<li>有孩子，<strong>把sum减掉根节点的值，去判断左右子树是否有</strong> ，<code>sum = sum - root.val</code></li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/112_path_sum/root_leaf_path_sum.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 节点为空</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 没有左右子树，直接判断</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val == sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 减小sum，去递归判断左右子树</span></span><br><span class="line">    <span class="keyword">int</span> newsum = sum - root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, newsum) || hasPathSum(root-&gt;right, newsum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目2 从根节点到叶子节点求和-保存路径-113</strong></p>
<p><a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">Path Sum-113</a>， <code>Medium</code></p>
<blockquote>
<p>给二叉树和sum值，找到root-to-leaf的路径，使得和为sum。保存该路径</p>
</blockquote>
<p><strong>思路</strong></p>
<p>用<code>vector&lt;int&gt; path</code> 来记录<strong>当前路径</strong>， <code>vector&lt;vector&lt;int&gt;&gt; res</code> 记录<strong>最终结果</strong></p>
<ul>
<li>根节点为空，返回</li>
<li>到达叶子节点，<code>val == sum</code>， 把<strong>当前节点加入path</strong>，<strong>当前path加入res</strong>， 否则返回</li>
<li>非叶子节点，<strong>把当前节点加入path</strong>，<strong>去左右子树中遍历</strong>，继续追加path直到叶子节点</li>
<li>非叶子节点，结束后，<strong>把当前节点从path中删除</strong></li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/113_path_sum_save/root2leaf_pathsum_save.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到树种从root到leaf的所有和为sum的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    find_path(root, sum, path, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归遍历节点，逐渐添加节点到当前的path，叶子节点，满足要求时，则把path追加到res中</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      root -- 当前节点</span></span><br><span class="line"><span class="comment"> *      path -- 当前路径</span></span><br><span class="line"><span class="comment"> *      res -- 所有路径</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_path</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum) &#123;</span><br><span class="line">            path.push_back(root-&gt;val);</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点加到path中</span></span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新sum，到左右子树中去添加path</span></span><br><span class="line">    <span class="keyword">int</span> newsum = sum - root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        find_path(root-&gt;left, newsum, path, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        find_path(root-&gt;right, newsum, path, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点从path中移除</span></span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目3 求二叉树的所有和为sum的路径，任意起始节点-437</strong></p>
<blockquote>
<p>给一颗二叉树和sum，求出所有和为sum的路径数量，从任意节点开始和结束。</p>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>层次遍历，<strong>以每一颗节点为起始值</strong>，找到以它开始的路径数量</li>
<li>节点为空，0</li>
<li>无孩子，不相等，0</li>
<li>无孩子，相等，1</li>
<li>有孩子，相等，<code>c = 1</code>， 不相等<code>c = 0</code>。 <strong>更新sum</strong>，继续<strong>递归查找左右孩子的count</strong>。返回<strong>c+count</strong></li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/437_all_path_sum/btree_all_path_sum.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到树中，和为sum的所有路径数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        count += count_from_root(now, sum);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;left) q.push(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;right) q.push(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以root为起始节点，向下走，和为sum的路径的条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_from_root</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 直接根节点就满足，无需看孩子</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        <span class="comment">// 相等</span></span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="comment">// 无孩子，不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c+左右孩子的</span></span><br><span class="line">    <span class="keyword">int</span> newsum = sum - root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> c + count_from_root(root-&gt;left, newsum) + count_from_root(root-&gt;right, newsum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有序链表转平衡bst-109">有序链表转平衡BST-109</h1>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">Convert Sorted List to Binary Search Tree</a>， <code>Medium</code>。 类似题型：<a href="https://plmsmile.github.io/2018/01/07/aim2offer3/#二叉搜索树转双向链表-36">BST转有序双向链表</a></p>
<blockquote>
<p>给一个有序链表，转化为平衡的二叉搜索树</p>
</blockquote>
<p><strong>思路</strong></p>
<p>有序 -- BST的中序遍历；平衡 -- 以中间节点为根节点，分为左右子树递归去创建。</p>
<ul>
<li>计算总结点数量 -- <code>size</code>， 递归去构建树<code>go(0, size - 1)</code></li>
<li><code>go(head, start, end)</code> ，计算出<strong>中间节点</strong><code>mid-node</code>， 构造<strong>树根</strong><code>root</code></li>
<li><strong>左孩子</strong><code>root.left = go(head, start, mid-1)</code>， <strong>右孩子</strong><code>root.right = go(now.next, mid+1, end)</code></li>
<li>返回当前树根节点root</li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/109_sortedlist_to_bst/list_to_bst.cpp" target="_blank" rel="noopener">关键代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 把有序链表转化为平衡的BST</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      head -- 链表</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      root -- 树的头结点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ++size;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> create_tree(head, <span class="number">1</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归中序创建树</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      head -- 链表头节点</span></span><br><span class="line"><span class="comment"> *      start -- 起始节点编号，从1开始</span></span><br><span class="line"><span class="comment"> *      end -- 结束节点编号</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      root -- 树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">create_tree</span><span class="params">(ListNode* head, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0. 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 找到中间节点，构建根节点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 递归构造左右子树</span></span><br><span class="line">    root-&gt;left = create_tree(head, start, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = create_tree(node-&gt;next, mid + <span class="number">1</span>, end);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="序列化二叉树-297">序列化二叉树-297</h1>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a>， <code>Hard</code></p>
<blockquote>
<p>把二叉树序列化为字符串，把字符串反序列化为一棵树</p>
</blockquote>
<p><strong>思路</strong></p>
<p><a href="https://plmsmile.github.io/2017/12/29/leetcode-01/#先序遍历-144">前序遍历</a>来保存序列，保存成一颗<strong>完全二叉树</strong>，空节点用<code>$</code>表示，使用空格进行分割。</p>
<p><strong>序列化</strong></p>
<ul>
<li>序列化为一颗完全二叉树，先序递归。遇到空指针，则用<code>$</code>代替<br>
</li>
<li>先把字符放到<code>stringstream</code>里面，<code>&lt;&lt;</code>输入， 最后<code>s.str()</code>得到字符串</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 把一棵树序列化为一个字符串，前序完全二叉树序列</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      root -- 树</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      str -- 序列化后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stringstream</span> buf;</span><br><span class="line">    build_string(root, buf);</span><br><span class="line">    <span class="keyword">return</span> buf.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归把二叉树序列化到buf字符串中</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      root -- 当前的根节点</span></span><br><span class="line"><span class="comment"> *      buf -- 字符串buffer</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      None，都写到了buf中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_string</span><span class="params">(TreeNode* root, <span class="built_in">stringstream</span>&amp; buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        buf &lt;&lt; <span class="string">"$"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    build_string(root-&gt;left, buf);</span><br><span class="line">    build_string(root-&gt;right, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>从字符串中解析得到序列，存到队列中</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分割字符串，把字符写到容器q里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;q, <span class="keyword">const</span> <span class="keyword">char</span> delim = <span class="string">' '</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">istringstream</span> input;</span><br><span class="line">    input.str(str);</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::getline(input, line, delim)) &#123;</span><br><span class="line">        q.push(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反序列化</strong></p>
<p>得到<strong>队列</strong>序列之后，可以对其进行递归反序列化构建树。先序序列，不是层次序列。</p>
<ul>
<li><strong>根-左-右</strong>，队列。<strong>出队</strong>，<strong>建立根节点</strong></li>
<li><strong>左-右</strong>，队列，递归建立<strong>左孩子</strong></li>
<li><strong>右</strong>，队列，建立<strong>右孩子</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 把String解析为一棵树</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      data -- 序列化后的字符串</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      root -- 树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序序列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; preorder;</span><br><span class="line">    split(data, preorder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build_tree(preorder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归先序构造树</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      prev -- 先序遍历序列</span></span><br><span class="line"><span class="comment"> * Retursn:</span></span><br><span class="line"><span class="comment"> *      root -- prev[i]为根构建的树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build_tree</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp; pres)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pres.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> val = pres.front();</span><br><span class="line">    pres.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前为空节点</span></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="string">"$"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有值</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归按照顺序构建左右子树</span></span><br><span class="line">    root-&gt;left = build_tree(pres);</span><br><span class="line">    root-&gt;right = build_tree(pres);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数字全排列-046">数字全排列-046</h1>
<p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">Permutations</a>, <code>Medium</code>。 <a href="https://plmsmile.github.io/2017/12/31/algorithm-dfs/#解空间树">搜索树</a></p>
<blockquote>
<p>给一个数组，返回全排列。每个数字都不相同</p>
</blockquote>
<p><strong>思路</strong></p>
<p>全排列<code>回溯法</code>搜索。一个数组，搜索第t层的时候</p>
<ul>
<li>前面t-1层都已经ok</li>
<li>遍历后面的所有元素，给到t层，去搜索</li>
<li>每次进行交换</li>
</ul>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/046_num_permutations/permutations.cpp" target="_blank" rel="noopener">github代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数组的全排列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回溯搜索排列树，遍历当前第i层的所有可能性，前面i-1已经全部确定好</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      t -- 第几层，[0, n-1]</span></span><br><span class="line"><span class="comment"> *      path -- 当前路径，[0,i-1]已经确定好，[i,n-1]是剩余的数字，遍历每一种可能给到i</span></span><br><span class="line"><span class="comment"> *      res -- 总的结果</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> t, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= path.size()) &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; path.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(path[t], path[i]);</span><br><span class="line">        dfs(path, t + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">std</span>::swap(path[t], path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重复数字全排列-047">重复数字全排列-047</h1>
<p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">重复数字全排列-047</a></p>
<blockquote>
<p>给一个数组，里面有一些重复的数字，给出所有的排列可能</p>
</blockquote>
<p><strong>思路</strong></p>
<p>重复的原因：当为t设置值的时候，遍历后面的所有元素给t赋值，但是后面都有一些重复的数值。</p>
<p>比如说 <code>1  2 1 1</code>， 开始是1，1会与最后的两个1再进行交换，然而其实是一样的。没必要了。</p>
<p>每次遍历交换的时候，<strong>只交换遍历后面不重复的元素</strong>。</p>
<p><a href="https://github.com/plmsmile/leetcode/blob/master/047_dup_nums_permutations/permutations.cpp" target="_blank" rel="noopener">github代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回溯搜索排列树，遍历当前第i层的所有可能性，前面i-1已经全部确定好</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      t -- 第几层，[0, n-1]</span></span><br><span class="line"><span class="comment"> *      path -- 当前路径，[0,i-1]已经确定好，[i,n-1]是剩余的数字，遍历每一种可能给到i</span></span><br><span class="line"><span class="comment"> *      res -- 总的结果</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> t, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= path.size()) &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不重复的元素与其索引</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; path.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals.find(path[i]) == vals.end()) &#123;</span><br><span class="line">            vals.insert(path[i]);</span><br><span class="line">            idx.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for_each(idx.begin(), idx.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">       <span class="built_in">std</span>::swap(path[t], path[i]);</span><br><span class="line">        dfs(path, t + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">std</span>::swap(path[t], path[i]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>组合问题</strong></p>
<blockquote>
<p>给n个字符，要组成m个字符，问有多少种组成方法</p>
</blockquote>
<p>有点类似于01背包的选择。</p>
<ul>
<li>选择第一个字符，则在后面选择m-1个字符</li>
<li>不选择第一个字符，则在后面选择m个字符</li>
</ul>
<p><strong>正方体顶点和相等问题</strong></p>
<blockquote>
<p>给8个数字，正方体有8个顶点，数字放在顶点上。使得3对对面的顶点和相等。</p>
</blockquote>
<p>也就是搜索，然后限定一些条件。</p>
<p><strong>8皇后问题</strong></p>
<blockquote>
<p>8*8的象棋摆8个皇后，任意两个皇后不能在同一行、同一列或同一对角线上。问有多少种摆法</p>
</blockquote>
<h1 id="n皇后问题-051">N皇后问题-051</h1>
<blockquote>
<p>n*n的棋盘摆n个皇后，任意两个皇后不能在同一行、同一列或同一对角线上。返回摆法。</p>
</blockquote>
<p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">N-Queens</a></p>
<ul>
<li>每一行一个皇后，每一行有n个选择。就去<strong>dfs搜索</strong>所有的排列树。</li>
<li><code>path[t]=k</code>， 第t行的皇后在第k列</li>
<li>k不能在前面皇后的：同一列、主对角线、<strong>副对角线</strong> 。别忘记副对角线。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回n皇后的解法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 1. 获得所有可能的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; locations;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n);</span><br><span class="line">    <span class="built_in">std</span>::iota(path.begin(), path.end(), <span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">0</span>, n, path, locations);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造返回结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> loc : locations) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; solu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : loc) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">line</span><span class="params">(n, <span class="string">'.'</span>)</span></span>;</span><br><span class="line">            line[i] = <span class="string">'Q'</span>;</span><br><span class="line">            solu.push_back(line);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(solu);</span><br><span class="line">    &#125;</span><br><span class="line">    show(res[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dfs，设置t行的皇后位置</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      t -- 第t行，从0开始</span></span><br><span class="line"><span class="comment"> *      n -- n皇后</span></span><br><span class="line"><span class="comment"> *      path -- 当前的路径方案</span></span><br><span class="line"><span class="comment"> *      res -- 总的方案</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == n) &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面t-1行已经ok，再后面的t-n个选择中选择遍历t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (legal(t, path[i], path) == <span class="literal">true</span>) &#123;</span><br><span class="line">            swap(path[i], path[t]);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "t=" &lt;&lt; t &lt;&lt; ", k=" &lt;&lt; path[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//for_each(path.begin(), path.end(), [](int i)&#123;cout &lt;&lt; i &lt;&lt; " ";&#125;);</span></span><br><span class="line">            dfs(t + <span class="number">1</span>, n, path, res);</span><br><span class="line">            swap(path[i], path[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 合法性判断，同一列、主对角线、副对角线</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      t -- 第t行，从0开始</span></span><br><span class="line"><span class="comment"> *      k -- 放在第k个列，从0开始</span></span><br><span class="line"><span class="comment"> *      path -- 当前的路径，[0,t-1]行已经放好</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">legal</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> k, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1. 不能和之前的在同一列</span></span><br><span class="line">        <span class="keyword">if</span> (path[i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 不能在主对角线上</span></span><br><span class="line">        <span class="keyword">if</span> (t - i == k - path[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 不能在副对角线上</span></span><br><span class="line">        <span class="keyword">if</span> (t + k == i + path[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p[%d]=%d,p[%d]=%d\n"</span>, t, k, i, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>N皇后问题-052</strong></p>
<blockquote>
<p>返回有多少种解法</p>
</blockquote>
<p>做了上面的题，那这个就很简单了，返回数量就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回n皇后的解法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; locations;</span><br><span class="line">    <span class="comment">// 当前的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n);</span><br><span class="line">    <span class="comment">// 初始化为0-n-1</span></span><br><span class="line">    <span class="built_in">std</span>::iota(path.begin(), path.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// dfs遍历搜索</span></span><br><span class="line">    dfs(<span class="number">0</span>, n, path, locations);</span><br><span class="line">    <span class="keyword">return</span> locations.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找第k大的数总结">查找第k大的数总结</h1>
<blockquote>
<p>给N个数，确定第k个最大值</p>
</blockquote>
<p><strong>1 排序</strong></p>
<p>排好序，取出第k大的值。<span class="math inline">\(O(n\log n + k)\)</span></p>
<p><strong>2 简单选择排序</strong></p>
<p><a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#简单选择">简单选择</a>。第k次选择，就是第k大的数字。<span class="math inline">\(O(n*k)\)</span></p>
<p><strong>3 快速排序思想</strong></p>
<p>每次partition，会把x放到位置i上。<strong>注意partition要从大到小排列，左大右小</strong>，而不是普通排序的左小右大。</p>
<ul>
<li><code>i == k</code>， 则就是<code>a[i]</code></li>
<li><code>k &gt; i</code>， 则在i的右边</li>
<li><code>k &lt; i</code>， 则在i的左边</li>
</ul>
<p>[关键代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用快排思想查找第k大的数字，从大到小排列！！</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      a -- 数组</span></span><br><span class="line"><span class="comment"> *      l -- 范围的开始</span></span><br><span class="line"><span class="comment"> *      r -- 范围的结束</span></span><br><span class="line"><span class="comment"> *      k -- 该范围内第k大的数</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      第k大的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_kth_num</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 划分。左边大，中间a[l]，右边小</span></span><br><span class="line">    <span class="keyword">int</span> i = partition(a, l, r);</span><br><span class="line">    <span class="comment">// 2. 通过i+1==k来判断是否是第k大的数</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">        <span class="comment">// 在左边</span></span><br><span class="line">        <span class="keyword">return</span> find_kth_num(a, l, i - <span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在右边</span></span><br><span class="line">        <span class="keyword">return</span> find_kth_num(a, i + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4 最大堆</strong></p>
<p><span class="math inline">\(O(4*n)\)</span>的空间建立最大堆，pop k次即可。<span class="math inline">\(O(4 \times n + k\times\log n)\)</span></p>
<p><strong>5 最小堆</strong></p>
<p>维护大小为k的最小堆，遍历数组</p>
<ul>
<li>堆顶元素大，则不管</li>
<li>堆顶元素小，则把当前值插入堆中</li>
<li>最后的堆顶，就是第k大的元素</li>
</ul>
<p><span class="math inline">\(O(n \times \log k)\)</span></p>
<p><strong>6 Hash法</strong></p>
<h1 id="查找最小的k个数的总结">查找最小的k个数的总结</h1>
<blockquote>
<p>给一个数组，找到最小的k个数。注意改变或不改变原数组</p>
</blockquote>
<p><strong>1 排序思路</strong></p>
<p>对n个数字从小到大排好序，再取前k个数。<code>O(nlogn + k)=O(nlogn)</code> 。<a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#总结比较">排序算法总结</a></p>
<p><strong>2 快速排序</strong></p>
<p>排好前k个即可，改变原数组。</p>
<p><strong>3 最大堆</strong></p>
<p>建立大小为k的最大堆。不改变原数组。遇到新的元素，小于堆顶，则加入</p>
<p><strong>4 堆排序</strong></p>
<p>对整个数组n进行堆排序，每次取堆顶，取k次。</p>
<h1 id="数组中次数超过一半的数-169">数组中次数超过一半的数-169</h1>
<p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Majority Element-169</a>， <code>easy</code></p>
<blockquote>
<p>一个数组，有一个元素出现次数超过一半，找到它。</p>
</blockquote>
<p><strong>思路0 先排序再找</strong></p>
<p><span class="math inline">\(O(n\log n)\)</span></p>
<p><strong>思路1 快速排序查找第k大元素思想</strong></p>
<p><a href="https://plmsmile.github.io/2017/12/26/sort-algorithms/#快速排序">快速排序笔记</a> 。</p>
<ul>
<li>如果排好序，则该重复的数字应该在数组中间<span class="math inline">\(a_{\frac{n}{2}}\)</span>。 也就是中位数，第<code>n/2</code>大的数字</li>
<li>问题就转化为<strong>查找数组中的K大的元素</strong></li>
</ul>
<p>查找第k大的元素</p>
<ul>
<li><code>partition(a, l, r)</code> 会把<code>x=a[l]</code>放到中间去，小于的在右边，大于的在左边。返回x的最终位置<code>i</code></li>
<li><code>i == k</code>， 则x就是第k大的元素</li>
<li><code>k &lt; i</code>， 则k在右边</li>
<li><code>k &gt; i</code>， 则k在左边</li>
<li>继续查找，知道 <code>i == k</code></li>
</ul>
<p><strong>思路2 count加加减减思想</strong></p>
<ul>
<li>遇见友军（相同的），就++</li>
<li>遇见敌军（不同的），就--</li>
<li>最后剩余的肯定就是人数最多的那个（数字）</li>
</ul>
<p>[关键代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找主元素，阵地攻守思想。相同加价，不同减减，为0重新赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority_element</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前数值与计数</span></span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == res) &#123;</span><br><span class="line">            <span class="comment">// 相同++</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不同--或者重置为1</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                res = a[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主元素2-229">主元素2-229</h1>
<blockquote>
<p>给一个数组，找到所有出现次数超过n/3的数</p>
</blockquote>
<p><a href="https://leetcode.com/problems/majority-element-ii/description/" target="_blank" rel="noopener">Majority Element II</a>, <code>medium</code> 。</p>
<p><strong>思路</strong></p>
<p>当然最终结果只有2个或1个。思路同阵地攻守。</p>
<ul>
<li>用两个变量去记录两个主元素</li>
<li>有一个相同，对应加1</li>
<li>两个都不同，有一个<code>count==0</code>， 则重置</li>
<li>两个都不听，两个都有count，则都减减</li>
<li>遍历之后，得到两个数，两个count</li>
<li>返回<code>count &gt; n/3</code>的数</li>
</ul>
<p>最后，一定要<strong>注意去重</strong>！<code>n1 != n2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找出现次数超过n/3的元素</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      nums -- 数组</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      res -- 超过n/3的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majority_element(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 找到出现次数最多的两个数</span></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == n1) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == n2) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="number">0</span>) &#123;</span><br><span class="line">            n1 = n;</span><br><span class="line">            c1 = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c2 == <span class="number">0</span>) &#123;</span><br><span class="line">            n2 = n;</span><br><span class="line">            c2 = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c1--;</span><br><span class="line">            c2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 重新计算出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == n) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n2 == n) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 把出现次数超过n/3的数字放到res里面</span></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; nums.size() / <span class="number">3</span>) &#123;</span><br><span class="line">        res.push_back(n1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> (n2 != n1 &amp;&amp; c2 &gt; nums.size() / <span class="number">3</span>) &#123;</span><br><span class="line">        res.push_back(n2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长不重复子字符串-003">最长不重复子字符串-003</h1>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters-003</a></p>
<blockquote>
<p>给一个字符串，找到里面最长子字符串的长度。</p>
</blockquote>
<p><strong>1 DP思路</strong></p>
<p>设<code>l[i]=k</code>， 是以<code>s[i]</code><strong>结尾</strong>最长字符串的长度是k。<strong>从左到右进行计算</strong>。遍历到<code>s[i]</code></p>
<p>1、 <code>s[i]</code>在前面<strong>没有出现过</strong>，<code>l[i] = l[i-1] + 1</code></p>
<p>2 、<code>s[i]</code>在<strong>前面出现过</strong>，计算该字符现在与前面<strong>两次出现的距离d</strong>，比较d和<code>s[i-1]</code>的最大长度<code>l[i-1]</code></p>
<ul>
<li><code>d &gt; l[i-1]</code>， <strong>d很远</strong>（不在i-1的最长字符串里），<code>l[i] = l[i-1] + 1</code></li>
<li><code>d &lt;= l[i-1]</code>，<strong>d很近</strong>（在i-1的最长字符串里），<code>l[i]=d</code></li>
</ul>
<p>使用<code>HashMap&lt;Char, Int&gt;</code>去记录位置信息，保留<strong>最近时间的出现位置</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符串中，最长不重复子串的长度，是连续</span></span><br><span class="line"><span class="comment"> * Args:</span></span><br><span class="line"><span class="comment"> *      s -- 原字符串</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *      len -- 最长子串长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">long_substr_len</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度，l[i]=k，以s[i]结尾的最大子串长度为k</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l(s.length(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 位置，m['a']=i，最近，字符a出现的位置是i</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            l[i] = <span class="number">1</span>;</span><br><span class="line">            m[ch] == i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m.find(ch) == m.end()) &#123;</span><br><span class="line">            <span class="comment">// ch 没出现过</span></span><br><span class="line">            l[i] = l[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ch 出现过，距离比较</span></span><br><span class="line">            <span class="keyword">int</span> d = i - m[ch];</span><br><span class="line">            <span class="keyword">if</span> (d &gt; l[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 上一个ch距离很远</span></span><br><span class="line">                l[i] = l[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 上一个ch距离很近</span></span><br><span class="line">                l[i] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新出现位置</span></span><br><span class="line">        m[ch] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(l.begin(), l.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="丑数-263-264-313">丑数-263-264-313</h1>
<p><a href="https://leetcode.com/problems/ugly-number/description/" target="_blank" rel="noopener">263-判断是否是丑数</a> ，<code>easy</code></p>
<blockquote>
<p>只包含2、3、5作为因子的正整数是丑数，1也是。判断是否是丑数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不断分解2,3,5</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            num /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/ugly-number-ii/description/" target="_blank" rel="noopener">264-找到第n个丑数</a> ，<code>medium</code></p>
<blockquote>
<p>找到第n个丑数</p>
</blockquote>
<p>如果依次找，所有的数都要分解求余，效率低。**丑数=丑数*{2,3,5}<strong>。 用数组去存放丑数，</strong>从1开始依次向前面递推计算。**</p>
<p>用<strong>3个索引</strong>，去分别保存<strong>乘以</strong><code>2,3,5</code>的基数，每次<strong>选择最小的</strong>作为下一个丑数，同时更新<strong>对应的索引++</strong>。</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第n个丑数，从已有的丑数不断地向前乘得到新的丑数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u(n);</span><br><span class="line">    u[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算丑数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算新的丑数，选择最小的</span></span><br><span class="line">        <span class="keyword">int</span> cur = min(min(u[t2] * <span class="number">2</span>, u[t3] * <span class="number">3</span>), u[t5]*<span class="number">5</span>);</span><br><span class="line">        u[i] = cur;</span><br><span class="line">        <span class="comment">// 更新基数索引</span></span><br><span class="line">        <span class="keyword">if</span> (cur == u[t2] * <span class="number">2</span>) &#123;</span><br><span class="line">            t2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == u[t3] * <span class="number">3</span>) &#123;</span><br><span class="line">            t3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == u[t5] * <span class="number">5</span>) &#123;</span><br><span class="line">            t5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.com/problems/super-ugly-number/description/" target="_blank" rel="noopener">313-超级丑数</a>， <code>medium</code></p>
<p>超级丑数是，<strong>给一个素数列表去计算丑数</strong>，不再局限于2,3,5去计算丑数。</p>
<blockquote>
<p>给一个素数列表和n，返回第n个丑数</p>
</blockquote>
<p>和上一个思路一致，用数组保存。注意t数组的初始大小是primes.size()，而不是n。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 给定素数，返回第n个丑数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || primes.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u(n);</span><br><span class="line">    u[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t(primes.size(), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 计算新的丑数，选择最小的</span></span><br><span class="line">        <span class="keyword">int</span> cur = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size(); ++j) &#123;</span><br><span class="line">            cur = min(cur, u[t[j]] * primes[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        u[i] = cur;</span><br><span class="line">        <span class="comment">// 更新索引，向前推进</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == u[t[j]] * primes[j]) &#123;</span><br><span class="line">                t[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-12-13T08:00:25.721Z" itemprop="dateUpdated">2018-12-13 16:00:25</time>
</span><br>


        
        <br>原始链接：<a href="/2017/12/29/leetcode-01/" target="_blank" rel="external">http://plmsmile.github.io/2017/12/29/leetcode-01/</a>
        
    </div>
    
    <footer>
        <a href="http://plmsmile.github.io">
            <img src="/img/avatar.jpg" alt="PLM">
            PLM
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树/">树</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://plmsmile.github.io/2017/12/29/leetcode-01/&title=《leetcode-01》 — PLM's Notes&pic=http://plmsmile.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://plmsmile.github.io/2017/12/29/leetcode-01/&title=《leetcode-01》 — PLM's Notes&source=
leetcode题目
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://plmsmile.github.io/2017/12/29/leetcode-01/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《leetcode-01》 — PLM's Notes&url=http://plmsmile.github.io/2017/12/29/leetcode-01/&via=http://plmsmile.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://plmsmile.github.io/2017/12/29/leetcode-01/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/12/29/10-trees/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">树的总结</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/12/29/aim2offer2/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">剑指offer(11-20)</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "kR8nND4dcsWgqDWIjpiH4YFj-gzGzoHsz",
            appKey: "il7PLkcJCfDBXMR6XirLdO2K",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            <span>
            PLM's Notes &nbsp; &copy; &nbsp
            </span>
            2016 - 2018
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://plmsmile.github.io/2017/12/29/leetcode-01/&title=《leetcode-01》 — PLM's Notes&pic=http://plmsmile.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://plmsmile.github.io/2017/12/29/leetcode-01/&title=《leetcode-01》 — PLM's Notes&source=
leetcode题目
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://plmsmile.github.io/2017/12/29/leetcode-01/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《leetcode-01》 — PLM's Notes&url=http://plmsmile.github.io/2017/12/29/leetcode-01/&via=http://plmsmile.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://plmsmile.github.io/2017/12/29/leetcode-01/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3aS44iMRAFwL7/pRlpVjPqBt5Lm5bKFV4hpMKOWiT58ddXvB5/17NvHv+s7998fzb/nc0LAwPjsozHy/WMkRwo2SWHvXkWAwPjBoyVUJiE470REgMDA+P1UZKAmKeMK68AAwMDIylKi9QtgGFgYGC8ZsxCZ/I6kl02vCYMDIyjGe1g4Dc/f3C+gYGBcRHGLAh+ot2/dCoMDIyjGW2Sl2+fjxbWU1IMDIw7MJLrEW2ymJSaeWFcFMwYGBiHMmaXHtoG2a6ae0PXEAMD44KM9gpFC9t1RaNODTEwMI5g5OXo7OizXepCGgMD4waMNhWbJY55GE12/O8pDAyMoxltItgmc3m7bRaOMTAw7sBYP3reemsPVwxEMTAwbsZI+nN5Ky1plrVNOgwMjHsyZiFvNnRsfy1KGTEwMI5m5A/noXbWqpsNMoupLAYGxmUZ+QCyPehsYJC354q+HQYGxsUZKwlZi/8Er/7fwMDAuCwj2SAPwe2ljdm1s6f/HhgYGMcx2qtae0vcWa+sfkMYGBhHMGatsZWEsmW/SRkxMDCOZrw+XNtoy4PvrhQTAwPjDoxHuVb68EkATcYVP+AxMDCOZsxKyvWxQV4MtwMGDAyMUxlJkN3VLGsvVRRnwMDAuAGj7bf//gDgTWGMgYGBEX/Oi8+Vy2Fv7oxgYGBgfPhaWHtdDAMD4z6Mtlk/C7t5KVuPTjEwMI5mrBSQsxA5SzTbwQMGBsYRjD/Qz/oIbqtq8wAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
